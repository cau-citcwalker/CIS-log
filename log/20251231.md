출근 10:20
- 오전에는 FastAPI 이어서 공부할 예정
> [!faq] StatusCode
> ```
> 2xx
>  - 200 OK - 요청 성공, 범용적, GET/POST/PUT/PATCH
>  - 201 Created - 요청 성공, 새로운 자원 생성, POST
>  - 204 No Content - 요청 성공, 응답할 자원 없음, DELETE
> ```
> ```
> 4xx
>  - 400 Bad Request - 요청 실패, 요청이 잘못된 경우(query param, body)
>  - 401 Unauthorized - 인증 실패
>  - 403 Forbidden - 권한 문제 or 잘못된 method
>  - 404 Not Found - 자원이 없는 경우 또는 잘못된 endpoint
> ```
> ```
> 5xx
>  - 500 Internal Server Error - 범용적인 서버 에러
>  - 502 Bad Gateway - Reverse Proxy에서 서버의 응답을 처리할 수 없는 경우
>  - 503 Service Unavailable - 서버가 요청을 처리할 수 없는 경우(e.g. 일시적 부하, 서버 다운)
> ```

서버 상태 코드를 학습했으니 본격적으로 코드에 써먹어보려고 한다.
```python
from fastAPI import HTTPException
```
먼저 잘못된 요청에 대한 처리를 위해 `HTTPException`을 import해준다.
기존 코드에서 서버 상태 코드를 입력해야 하는 부분에 모두 추가해보면
```python
@app.get("/datas", status_code=200) # 정상 처리
def get_datas_handler():
	return data.values()

@app.get("/datas/{data_id}", status_code=200) # 정상 처리
def get_data_handler(data_id: int):
	data = data.get(data_id) # data값을 가져옴, 없으면 None
	if data: # 있으면
		return todo
	raise HTTPException(status_code=404, detail="Data not found") # 없으면 404 반환

@app.post("/datas", status_code=201) # 새로 데이터를 추가하는 요청을 정상 처리
def create_data_handler(request: CreateDataRequest):
	data[request.id] = request.dict()
	return data[request.id]

@app.patch("/datas/{data_id}", status_code=200) # 정상처리
def update_data_handler(
	data_id: int,
	is_super: bool = Body(..., embed=True)
):
	data = data.get(data_id)
	if data:
		data["is_super"] = is_super
		return data
	raise HTTPException(status_code=404, detail="Data not found") # 없으면 404 반환

@app.delete("/datas/{data_id}", status_code=204) # 삭제 처리에 대한 정상 처리
def delete_data_handler(data_id: int):
	data = data.pop(data_id, None)
	if data: # 존재하면
		return
	raise HTTPException(status_code=404, detail="Data not found") # 없으면 404 반환
```

다시 서버를 실행하려고 하니
```log
Error loading ASGI app. Could not import module "main".
```
이런 오류를 반환하길래 당황했었다.
가상 환경 설정이 잘못된건가? main을 왜 못불러오지?
결론은 하나였다. src폴더에 들어가지 않은 것.
현재 디렉토리에 `main.py`가 없기 때문에 이러한 현상이 일어나는 것이다. (해결)

---

> [!faq] 데이터베이스?
> - 대량의 데이터를 영구적으로 저장/관리하기 위한 시스템
> > [!example] 분류
> >- 관계형 데이터베이스 (Relational database, RDB; SQL)
> >	- 관계형 모델에 기반해서 데이터를 테이블, 행, 열 구조로 관리(=Schemaful)
> >	- Oracle, MySQL, PostgreSQL, SQLite
> >- 비관계형 데이터베이스 (NoSQL)
> >	- Key-value : Redis, etcd
> >	- Document : MongoDB
> >	- Wide-column : Cassandra, ScyllaDB
> >	- Timeseries : Apache Druid, InlfluxDB
> >	- Graph Neo4j
---
> [!info] sqlalchemy
> - 관계형 데이터베이스를 사용하기 위한 High-level 인터페이스를 제공하는 Python 라이브러리
> 	- ORM, Query, Transaction, Connection Pooling
> - ORM (Object-Reloational Mapping)
> 	- 관계형 데이터베이스를 객체 지향 프로그래밍(OOP)에 대응하여 사용하는 기술
> 	- 하나의 table = 하나의 class
> 	- 하나의 행 = 하나의 객체
> 

DB에서 표현되는 걸 Python으로 다음과 같이 표현할 수 있음

| D   | B        |               Python               |
| --: | -------- | :----------------------------------: |
| id  | username | user = User(id=1, username="user") |
| 1   | user     |                                    |

본격적으로 docker를 통해 시작해보겠음
```cmd
docker run -p 3306:3306 -e MYSQL_ROOT_PASSWORD=datas -e MYSQL_DATABASE=datas -d -v datas:/db --name datas mysql:8.0
```
-p 포트 지정 local:docker (default:3306)
-e 환경 변수 지정
-d 백그라운드 detach
-v volume 생성
`--name` 도커 컨테이너 이름 지정
`<도커 이미지>`

도커로 진입하면
```cmd
docker exec -it datas bash
```
datas 컨테이너의 bash에 접속할 수 있다
```bash
mysql -u root -p
```
위 명령어를 통해 `mysql`에 접속할 수 있다
SQL 안에서 좀 조작을 해보자면
```mysql
show databases; -- 데이터베이스 리스트를 보여주는 명령어
use datas; -- datas DB를 쓰겠다는 명령어
create table datas(
	-> id INT NOT NULL AUTO_INCREMENT,
	-> name VARCHAR(256) NOT NULL,
	-> is_super BOOLEAN NOT NULL,
	-> PRIMARY KEY (id)
	-> ); -- table을 만드는 명령어
insert into datas (name, is_super) values ("naa", true); -- datas 테이블에 값을 채워넣는 명령어
insert into datas (name, is_super) values ("na?", false);
select * from todo; -- todo에 있는 값들을 보여주는 명령어
```

데이터를 채워 넣었으니 python에서 DB를 연결할 차례
먼저 필요한 라이브러리들을 다운 받아줍니다
```cmd
pip install sqlalchemy pymysql cryptography
```
`src` 폴더 안에 `database`라는 폴더를 만들어줍니다
`database` 폴더 안에 `connection.py` 파일을 만들어주고 내용을 작성합니다
```python
from sqlalchemy import create_engine
from sqlalchemy.orm import sessionmaker

DATABASE_URL = "mysql+pymysql://root:data@127.0.0.1:3306/datas"

engine = create_engine(DATABASE_URL, echo=True)
SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)

def get_db(): # 컨트롤러
    session = SessionLocal()
    try:
        yield session
    finally:
        session.close()
```
`database` 폴더 안에 `orm.py` 파일을 만들어주고 내용을 작성합니다
```python
from sqlalchemy import Boolean, Column, Integer, String
from sqlalchemy.orm import declarative_base

Base = declarative_base()

class Data(Base):
    __tablename__ = "data"

    id = Column(Integer, primary_key=True, index=True)
    name = Column(String(256), nullable=False)
    is_super = Column(Boolean, default=False)
    
    def __repr__(self):
        return f"Data(id={self.id}, name={self.name}, is_super={self.is_super})"
```
`database` 폴더 안에 `repository.py` 파일도 만들고 내용을 작성합니다
```python
from typing import List
from sqlalchemy import select
from sqlalchemy.orm import Session
from src.database.orm import Data

def get_datas(session: Session) -> List[Data]:
    return list(session.scalars(select(Data)))
```

이렇게 필요한 DB 컨트롤 파일들을 작성하고 다시 `main.py`에 돌아와서 원래 딕셔너리로 진행했던 부분들을 DB로 바꿔준다.
먼저 필요한 라이브러리들을 import 해준다
```python
from typing import List
from fastapi import Depends
from sqlalchemy.orm import Session
from src.database.connection import get_db
from src.database.orm import ToDo
from src.database.repository import get_datas
```
그리고 이제 기본적인 것부터 바꿔보겠다.
```python
@app.get("/datas", status_code=200)
def get_datas_handler(order: str | None = None,
                      session: Session = Depends(get_db)
                      ):
    datas: List[Data] = get_datas(session=session)
    if order == "DESC":
        return list(reversed(datas))
    return datas
```

여기까지 작업하고 집중이 잘 되지 않아서 직군을 바꿔보려 한다.

---

이제 프론트엔드(React)를 공부할 것이다.
내가 수강하는 강좌에서는 React는 Nodejs기반 js라이브러리이기에 기초 js를 먼저 학습한다고 한다.

> [!info] 웹 개발에 들어가며
> - 웹 개발 기본 3요소 html(뼈대), css(스타일), js(기능)
> - 웹 브라우저에서 개발자 도구를 통해 Console 탭에서 JS를 입력할 수 있다.
> - IDE 환경은 VSC를 활용할 예정

프로그래밍 언어를 공부하면 가장 처음 입력하는 Hello world 구문을 입력해보자
```js
console.log("Hello world");
```

출력 함수를 배웠으니 변수를 선언해보자
자바스크립트에서 기본적으로 변수를 선언하는 약어는 `let`이다
```js
let age = 21;
```
상수를 선언하는 약어는 `const`이다. 상수는 값을 변경할 수 없다
```js
const birth = "2006.11.15"
```
변수 명명규칙은 다른 언어들과 동일하다
(+) 변수 명명 가이드
	기능 이름을 변수 이름으로 작성하는 것이 좋다 (당연한 말)

자료구조를 살펴보면 다음과 같다
```mermaid
graph LR
자료구조 --> 원시타입
원시타입 --> Number
원시타입 --> String
원시타입 --> Boolean
원시타입 --> Null
원시타입 --> Undefined
자료구조 --> 객체타입
객체타입 --> Object
Object --> Array
Object --> Function
Object --> RegexExp
```

좀 특이한 값으로 보이는 건 `infinity`, `-infinity`, `NaN`이 있었다.
>[!faq] NaN?
>Not a Number의 줄임말이다
>Num *** String 과 같은 식의 결과로 반환된다

변수의 값을 String안에서 동적으로 지정할 수 있다
```js
let a = 5;
console.log(`a is ${a}`);
```

`null`과 `undefined`는 같지 않다
```js
let a = null; // null
let b; // undefined
```

변수 간 형 변환이 가능하다
 - 묵시적 형 변환 = 자동으로 형 변환 (js가 좀 특이하게 이게 됨)
 - 명시적 형 변환 = 타입 캐스팅으로 두르면 된다
 ```js
	 Number(str) // String -> Number
	 parseInt(str) // 문자가 섞여있는 경우
	 String(num) // Number -> String
 ```

연산자는 다른 언어들과 동일하다
다른 점이 있다면 비교 연산자를 사용할 때 `===`을 활용해야 한다
`==` 이렇게 2개만 활용할 경우 자동 묵시적 형 변환으로 인해 데이터 타입이 달라도 같다고 반환될 수 있다

자바스크립트 만의 특이한 연산자
 - var1 `??` var2 : 둘 중 `null`이 아닌 값 하나를 반환 (앞 변수가 우선)
 - `typeof` var : 변수의 데이터 타입을 반환
 - `<조건식> ? var1 : var2` 조건식이 참이라면 var1을, 거짓이라면 var2를 반환

조건문은 if-else문, switch문이 존재한다
반복문은 for문, while문, do-while문이 존재한다

함수 선언은 다음과 같이 할 수 있다
```js
function func(var1, var2) {
	return var1;
}
```
좀 특이한 점이 있다면 리턴 타입을 굳이 명시하지 않아도 된다는 점이다
이 부분은 `python`과 유사하다고 볼 수 있다

```js
function func1(var1, var2) {
	function func2() {
		console.log("aa");
	}
	func2();
}
```
위와 같이 중첩 함수도 가능하다

또 한 가지 특이한 점은 선언문이 호출문 보다 아래에 있어도 인터프리터가 자동으로 위로 올려서 실행시키기 때문에 어디에 있든 상관없다

함수를 하도 많이 사용하다 보니 귀찮은 개발자들이 자바스크립트에서는 간략하게 쓰기로 했다
```js
let var = (var1) => {
	...
	return var2
};
```
이런 식도 함수다.. (화살표 함수)
더 놀라운 건 리턴 값만 있으면 되는 함수의 경우 이것마저도 귀찮았는지 더 축약할 수 있다..
```js
let var = (var1) => var2;
```

함수의 매개 변수 값으로 함수를 받는 콜백 함수도 있다
```js
function main(var) {
	console.log(var);
}
function sub() {
	console.log("Sub");
}
main(sub)
```
---
```log
f sub() {
	console.log("Sub");
}
```
이런 식으로 함수가 어떻게 생겼는 지를 출력할 수도 있다
만약에 안에서 실행하려면 `main`함수 안에서 `var()`을 쓰면 된다

> [!faq] Scope?
> 변수의 접근 범위를 뜻한다
> - 전역 Scope
> - 지역 Scope

객체를 통해 자료를 저장할 수도 있다
```js
let person = {
	name: "name",
	age: 21,
	location "어딘가"
};
```
이 값에 접근할 때는 `person.name` 또는 `person["name"]`을 통해 접근할 수 있다
없던 값을 호출하면 `undefined`가 반환된다
새로 값을 추가, 수정할 때는 다음과 같이 할 수 있다
```js
person.job = "student";
person["job"] = "student";
```
위 방식 중 원하는 방식을 활용하면 된다
값을 삭제하려면
```js
delete person.job;
delete person["job"];
```
마찬가지로 원하는 방식으로 삭제하면 된다
안에 값이 존재하는지 확인하는 방법은
```js
let res = "name" in person;
```
과 같이 boolean 타입으로 반환된다
`python`의 `dictionary`와 문법 구조가 유사하다

객체를 상수로 정의할 경우
```js
const animal = {
	type: "고양이",
	name: "괭이",
	color: "black"
}
```
객체를 새로 정의 하는 건 불가능하지만
```js
animal.age = 2;
animal.name = "고먐미";
delete animal.color;
```
값을 새로 추가하거나 수정하거나 삭제하는 건 가능하다

`js`에서 `method`를 선언하려면
```js
const person = {
	sayHi: function() {
		console.log("Hi");
	}
	say(var) {
		console.log(var);
	}
}
```
위와 같이 선언할 수 있다.
사용은 `person.sayHi()`와 같이 쓸 수 있다

배열 선언은 `[]`를 통해 생성하거나 `new Array()` 객체를 활용할 수도 있다
각 요소에 접근은 `arr[0]`와 같이 접근하면 된다

>[!faq] Truthy & Falsy?
> js에서 참이나 거짓을 의미하는 값이 아니지만 조건문에서 참이나 거짓으로 평가되는 특징
> > [!example] 예를 들면
> > - undefined == False
> > - null == False
> > - NaN == False
> > - 0 == False
> > - -0 == False
> > - "" == False
> > - 0n == False
> > - "hello" == True
> > - 123 == True
> > - [] == True
> > - {} == True
> > - () => {} == True
> 
>주로 값이 존재하는지 여부를 확인할 때 사용됨

### 진도
---
FastAPI 21 -> 30
React 1 -> 21

### 오늘의 메모
---
풀스택 한다고 하길 잘한 것 같은 점이 있다면, 학습비를 2배로 받을 수 있다는 것과 하나 하다가 질리면 다른 거 공부하면 된다는 점이지만, 그만큼 총 공부량이 많아진다는 것이 함정...ㅋㅋㅋ
연말인데 오늘은 열심히 하고 내일은 놀아야지...ㅋㅋㅋ....
내일 밥 어떻게 하지..

퇴근 18:43
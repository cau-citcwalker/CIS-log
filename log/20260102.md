출근 9:26
- 오늘은 프론트 JS 심화과정 먼저 끝내고 FastAPI 볼 예정

> [!faq] 단락평가
> js에서는 논리 연산자가 and 또는 or 연산을 할 때 앞의 식 만으로 값이 확정된다면 뒤의 식을 실행하지 않는다
> ```js
> function returnFalse() {
> 	console.log("False 함수");
> 	return false;
> }
> function returnTrue() {
> 	console.log("True 함수");
> 	return true;
> }
> console.log(returnFalse() && returnTrue());
> console.log(returnTrue() || returnFalse());
> ```
> 위와 같은 식이 있으면 결과 값은 `False 함수` 1번, `True 함수` 1번 출력이 나오게 됨
---
> [!faq] 구조 분해 할당
> 배열의 각 값들을 각각의 변수들에 대입해주는 것
> ```js
> let arr = [1, 2, 3];
> let [one, two, three] = arr;
> ```
> 객체에서도 가능함
> ```js
> let person = {
> 	name: "na",
> 	age: 21,
> 	hobby: "coffee"
> }
> let {n, a, h} = person;
> ```
---
> [!faq] Spread 연산자
> 객체나 배열에 저장된 여러 개의 값을 개별로 흩어주는 역할
> ```js
> let arr1 = [1, 2, 3];
> let arr2 = [4, ...arr1, 5, 6];
> 
> let obj1 = {
> 	a: 1,
> 	b: 2
> }
> let obj2 = {
> 	...obj1,
> 	c: 3,
> 	d: 4
> }
> ```
---
> [!faq] Rest 매개변수
> 나머지 매개변수라는 뜻
> ```js
> function func(one, two, ...rest) {
> 	console.log(rest);
> }
> ```
>  > [!warning] 주의사항
>  > Rest 매개변수 뒤에는 다른 매개변수를 받아올 수 없음

| 원시타입 | 객체타입 |
| :--: | :--: |
| 불변값  (값이 변할 경우 가리키는 데이터가 바뀜) | 가변값  (값이 변해도 데이터 주소값이 그대로) |
> [!info] 객체타입 주의사항
> 1. 의도치 않게 값이 수정될 수 있다
> 	- shallow copy : 객체의 참조값을 복사함 -> 원본 객체가 수정될 수 있어서 위험
> 	- deep copy : 새로운 객체를 생성하면서 property만 따로 복사함 -> 원본 객체가 수정될 일이 없어 안전
> 2. 객체간의 비교는 기본적으로 참조값을 기준으로 이루어진다
> 	```js
> 	let o1 = { name: "na" };
> 	let o2 = o1;
> 	let o3 = { ...o1 };
> 	o1 === o2; // true
> 	o1 === o3; // false
> 	```
> 	비교하려면 객체를 문자열로 변환하여 비교해야한다
> 	```js
> 	JSON.stringify(o1) === JSON.stringify(o3); // true
> 	```
> 3. 배열과 함수도 사실 객체다
> 	```mermaid
> 	graph TD
> 	객체(Object) -- 호출, 선언, ... --> 함수(Function)
> 	객체(Object) -- 순차 저장, 순회, ... --> 배열(Array)
> 	```
---
> [!example] 반복문으로 배열과 객체 순회하기
>  > [!faq] 순회
>  > 배열, 객체에 저장된 여러 개의 값에 순서대로 접근하는 것
> ```js
> for(let value of numbers) {
> 	console.log(value);
> }
> for(let key in Object.keys(person)) { //Object.values
> 	console.log(key, person[key]);
> }
> ```
> 배열을 순회할 때는 `of` 객체를 순회할 때는 `in`
---
> [!info] 배열 method
> ```js
> let arr = [1, 2, 3];
> ```
> > [!example] 요소 조작
> > ```js
> > const newLength = arr.push(4, 5, 6, 7); // 뒤에 추가
> > let poppedItem = arr.pop(); // 뒤에서부터 제거
> > let shiftedItem = arr.shift(); // 앞에서부터 제거
> > const newLength2 = arr.unshift(0); // 앞에서부터 추가
> > let sliced = arr.slice(2, 5); // n번째부터 n-1번째 까지 잘라냄; 숫자 하나만 쓰면 앞에서부터 갯수대로 잘라냄; 음수는 뒤에서부터
> > let concatedArr = arr.concat(arr2); // 2개의 배열을 하나로 합침
> > ```
> > `push`와 `pop`이 `shift`와 `unshift`보다 빠르다
>
> > [!example] 순회와 탐색
> > `forEach`문을 통해 배열을 순회할 수 있다
> > ```js
> > arr.forEach(function(item, idx, arr) {
> > 	console.log(idx, item * 2);
> > });
> > arr.forEach((item) => {
> > 	arr2.push(item * 2);
> > });
> > ```
> > `includes`문을 통해 요소가 포함되어 있는지 `boolean` 값으로 받아올 수 있다
> > ```js
> > let isInclude = arr.includes(3);
> > ```
> > 특정 요소의 `index`값을 받아오려면 `indexOf` 또는 `findIndex`문을 활용하면 된다
> > ```js
> > let index = arr.indexOf(3); // 만약 존재하지 않다면 -1을 반환함
> > const findedIndex = arr.findIndex((item) => {
> > 	if(item === 2) return true;
> > });
> > 
> > ```
> > `indexOf`문은 `shallow copy`를 기본으로 동작하기 때문에 `Object`타입에서 찾아낼 때는 `findIndex`문을 활용해야한다
> > 객체타입에서 필요한 데이터를 찾아서 그 객체를 반환해야 할 때는 `find`문을 쓰면 된다
> > ```js
> > let arrO = {
> > 	{name: "a"},
> > 	{name: "b"}
> > }
> > const finded = arrO.find(
> > 	(item) => item.name === "a"
> > );
> > ```
> 
> > [!example] 변형
> > 특정 조건을 만족한 요소들만 새로 배열로 반환하려면 `filter`문을 활용하면 된다
> > ```js
> > let arr1 = {
> > 	{name: "a", typ: "T"},
> > 	{name: "b", typ: "T"},
> > 	{name: "c", typ: "F"}
> > }
> > const tarr = arr1.filter((item) => item.typ === "T");
> > ```
> > 배열의 모든 요소를 순회하면서, 각각 콜백함수를 실행하고 결과값들을 새로운 배열로 반환하려면 `map`문을 활용하면 된다
> > ```js
> > const mapResult = arr.map((item, idx, arr) => {
> > 	return item * 2;
> > });
> > let names = arr1.map((item) => item.name);
> > ```
> > 배열을 (사전순) 정렬하려면 `sort`문을 활용하면 된다
> > ```js
> > let arrS = ["b", "a", "c"];
> > arrS.sort();
> > arr.sort((a, b) => { // 숫자를 정렬할 때에는 조건을 달아줘야함; 사전순서대로 정렬되기 때문
> > 	if(a > b) {
> > 		return 1; // 자리 바꾸기
> > 	}else if(a < b) {
> > 		return -1; // 원래대로 배치
> > 	}else {
> > 		return 0; // 안바꾸기
> > 	}
> > });
> > ```
> > 정렬한 배열을 새로 반환하려면 `toSorted`문을 쓰면 된다
> > ```js
> > const sorted = arrS.sorted(); // sort문과 문법 구조는 차이가 없음
> > ```
> > 배열의 모든 요소를 하나의 문자열로 합쳐서 반환하려면 `join`문을 활용하면 된다
> > ```js
> > const joined = arrS.join();
> > ```
---
> [!info] Date
> ```js
> let date1 = new Date(); // 현재 시간
> let date2 = new Date("1972-11-21"); // 특정 시점 -./ 아무거나 쓰면 됨
> ```
> TimeStamp : 1970.01.01 0시 0분 0초 (UTC) 로부터 몇 ms가 흘렀는지 의미하는 숫자값
> ```js
> let ts1 = date1.getTime();
> let date3 = new Date(ts1);
> ```
> 시간 요소를 추출하려면
> ```js
> let year = date1.getFullYear(); // 연도
> let month = date1.getMonth() + 1; // 월
> let date = date1.getDate(); // 일
> let hour = date1.getHours(); // 시
> let minute = date1.getMinutes(); // 분
> let seconds = date1.getSeconds(); // 초
> ```
> 시간 요소를 수정하려면
> ```js
> date1.setFullYear(2026);
> date1.setMonth(1);
> date1.setDate(2);
> date1.setHours(13);
> date1.setMinutes(46);
> date1.setSeconds(53);
> ```
> 원하는 format형식으로 출력하려면
> ```js
> console.log(date1.toDateString()); // Fri Jan 2 2026
> console.log(date1.toLocalString()); // 2026. 1. 2. 오후 1:46:53
> ```
---
> [!faq] 동기
> 여러 개의 작업들을 순서대로 처리하는 것; 한번에 하나씩 = `Thread`
> ```mermaid
> graph LR
>  TaskA --> TaskB
>  TaskB --> TaskC
> ```
> - 만약 TaskB 작업이 오래 걸릴 경우 서비스 전체가 다운될 수 있음
> - 이걸 보완하기 위해 다른 언어들`ex) Java`에서는 `Multi Thread`방식을 활용함
> - but, js에는 `thread`가 1개 밖에 존재하지 않음

> [!check] 비동기
> - `js`에서는 이 문제를 해결하기 위해 비동기 방식을 활용함
> - 비동기란, 앞의 작업이 끝나지 않았어도 다른 작업을 실행하는 것을 말함
> - `return`값으로 다른 일을 처리하고 싶으면 `callback`함수를 뒤에 쓰면 됨
> ```js
> console.log(1);
> setTimeout(() => {
> 	console.log(2);
> }, 3000);
> console.log(3);
> ```
> ```log
> 1
> 3
> 2
> ```
> `setTimeout`함수는 `WebAPI`에게 할 일을 떠넘기는 함수임 ~~(나빴다...)~~

여기까지 하고 다시 직종을 바꿔볼거임

---
- HTTP Request를 처리하는 법 부터 시작할거임
`src` 폴더 안에 `schema` 폴더를 만들고 `schema` 폴더 안에 `response.py` 파일을 만들고 내용을 작성한다.
```python
from pydantic import BaseModel

class DataSchema(BaseModel):
    id: int
    contents: str
    is_super: bool

    class Config: # ORM 모드를 쓰기 위함
        orm_mode = True

class ListDataResponse(BaseModel): # 나중에 불러오는 값을 다양하게 할 때를 위해서 분리
    datas: list[DataSchema]
```
그리고 `main.py`에서도 handler의 리턴값을 바꿔준다
```python
@app.get("/datas", status_code=200)
def get_datas_handler(order: str | None = None,
                      session: Session = Depends(get_db)
                      ) -> ListDataResponse:
    datas: List[Data] = get_datas(session=session)
    if order == "DESC":
        return ListDataResponse(
	        datas=[
	            DataSchema.from_orm(data) for data in reversed(datas)
	        ]
        )
    return ListDataResponse(
        datas=[
            DataSchema.from_orm(data) for data in datas
        ]
    )
```

이번엔 단일 API에도 `orm`을 적용해볼 것임
먼저 `repository.py` 파일에서 단일 조회 기능을 추가해줄거임
```python
def get_data_by_id(session: Session, data_id: int) -> Data | None:
    return session.scalar(select(Data).where(Data.id == data_id))
```
다시 `main.py`로 돌아와서 단일 조회 handler를 수정해주면 됨
```python
@app.get("/datas/{data_id}", status_code=200)
def get_data_handler(
    data_id: int,
    session: Session = Depends(get_db)
) -> DataSchema:
    data: Data | None = get_data_by_id(session=session, data_id=data_id)
    if data:
        return DataSchema.from_orm(data)
    raise HTTPException(status_code=404, detail="Data not found")
```

`main.py`에 있는 `CreateDataRequest` class를 리팩토링할거임
`schema` 폴더 안에  `request.py` 파일을 생성하고 `CreateDataRequest` class 구문만 옮겨주면 됨
그리고 `response.py`에서 `ListDataResponse` class의 이름을 `DataListSchema`로 바꿔주면 됨

이번엔 `post`부분에 `orm`을 적용해볼거임
원래는 `data -> orm -> pydantic` 순이었는데 `create` 에서는 반대로 `pydantic -> orm -> data` 순서로 진행해주어야함
그래서 `orm.py`를 먼저 수정할 것임
`Data` class 안에서 `classmethod`를 먼저 작성해주고
```python
@classmethod
def create(cls, request: CreateDataRequest) -> "Data":
    return cls(
        name=request.name,
        is_super=request.is_super
    )
```
`repository.py` 파일에서 `create` 기능을 추가한다
```python
def create_data(session: Session, data: Data) -> Data:
    session.add(instance=data)
    session.commit() # save db
    session.refresh(instance=data) # read db -> data_id
    return data
```
`main.py`로 돌아와서 `post` 기능을 수정한다
```python
@app.post("/datas", status_code=201)
def create_data_handler(
    request: CreateDataRequest,
    session: Session = Depends(get_db)
) -> DataSchema:
    data: Data = Data.create(request=request)
    data: Data = create_data(session=session, data=data)
    return DataSchema.from_orm(data)
```
그리고 `id`값은 자동으로 index가 붙고 있으므로 `CreateDataRequest` class 에서 삭제한다

이제 `patch`를 수정할거임
`orm.py`에서 `is_super` 값을 스위치 해주는 구문을 추가할거임
```python
def tosuper(self) -> "Data":
        self.is_super = True
        return self

def notsuper(self) -> "Data":
    self.is_super = False
    return self
```
그리고 `repository.py` 파일에서 `update`기능을 추가할 거임
사실 `create` 기능과 별반 다르지 않긴 함
```python
def update_data(session: Session, data: Data) -> Data:
    session.add(instance=data)
    session.commit()
    session.refresh(instance=data)
    return data
```
이제 `main.py`에서 `patch`기능에 `orm`을 연결하겠음
```python
@app.patch("/datas/{data_id}", status_code=200)
def update_data_handler(
    data_id: int,
    is_super: bool = Body(..., embed=True),
    session: Session = Depends(get_db)
):
    data: Data | None = get_data_by_id(session=session, data_id=data_id)
    if data:
        data.tosuper() if is_super else data.notsuper()
        data: Data = update_data(session=session, data=data)
	        return DataSchema.from_orm(data)
    raise HTTPException(status_code=404, detail="Data not found")
```

이제 마지막으로 `delete`에 `orm`을 적용해보겠음
`repository.py` 파일에 가서 `delete` 기능을 추가할거임
```python
def delete_data(session: Session, data: Data) -> None:
    session.execute(delete(Data).where(Data.id == data.id))
    session.commit()
```
이제 `main.py`에 돌아와서 `delete`에 `orm`을 적용시켜보겠음
```python
@app.delete("/datas/{data_id}", status_code=204)
def delete_data_handler(
    data_id: int,
    session: Session = Depends(get_db)
):
    data: data | None = get_data_by_id(session=session, data_id=data_id)
    if not data:
        raise HTTPException(status_code=404, detail="Data not found")
    delete_data(session=session, data=data)
```

### 진도
---
React 22 -> 31
FastAPI 31 -> 36

### 오늘의 메모
---
백엔드 부분의 난이도가 올라오면서 이해해야할 개념이 늘고 있음
ORM이라는 개념은 원래 알고 있었지만 무료 자료로는 알 수 있는 게 한정적이었음
오늘은 코드를 작성하는 시간보다 이해하려고 머리 굴린 시간이 더 많은듯 함
그나저나 오늘 점심 학식 새해 기념 떡국 무료 너무 좋아요 :)
프론트 부분은 js에서 원래 알던 내용이 너무 많아서 몇가지 용어만 정리한 듯
이제 다음부터 프론트는 NodeJS 파트로 넘어가고, 백엔드는 PyTest로 테스트 코드 실행하는 단계로 넘어갈 예정
오늘 랩실에 또 한짓이 있다면 에스프레소 머신 청소함 & 원두 갈아 끼움
갈고 나서 첫 잔을 내가 마셨는데, 강배전 원두가 안에 남아있었는데다 머신 세팅도 안맞아서 상당히 힘들었음
담번엔 머신 세팅을 꼭 하는거로
평상시보다 좀 일찍 끝나서 진도를 더 나가보려고 했지만 둘 다 새로운 섹션 시작이라 어려울 듯..
둘 다 마무리되면 그때부터 도커 공부하고, AI 몇가지 깔짝해보고, 원래 관심사였던 보안 분야를 서브로 파볼 예정
그래서 K-MAP 프로젝트에서 대체 불가능 자원으로 보안을 서브로 달린다는 점을 가져가고 싶음

퇴근 18:15
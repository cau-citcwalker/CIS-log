출근 10:10
- 오늘은 오랜만에 백엔드로 돌아갈듯
- 오전 타임은 컴세팅 도와드리림

우선 GET 전체 조회 API를 테스트하는 코드를 작성하면
```py
def test_get_todos():
    response = client.get("/todos")
    assert response.status_code == 200
    assert response.json() == {
        "todos": [
            {"id": 1, "contents": "FastAPI Section 0", "is_done": True},
            {"id": 2, "contents": "FastAPI Section 1", "is_done": True},
            {"id": 3, "contents": "FastAPI Section 2", "is_done": True}
        ]
    }
    response = client.get("/todos?order=DESC")
    assert response.status_code == 200
    assert response.json() == {
        "todos": [
            {"id": 3, "contents": "FastAPI Section 2", "is_done": True},
            {"id": 2, "contents": "FastAPI Section 1", "is_done": True},
            {"id": 1, "contents": "FastAPI Section 0", "is_done": True}
        ]
    }
```
기존 코드와 차이가 있다면 역방향 정렬 코드를 아래에 추가했다

이제 `mocking`을 추가하겠다
> [!faq] Mocking?
> 일반적인 데이터를 가지고 테스트를 한다면 테스트 코드 실행시간이 너무 길어질 수도 있기에 실제 데이터를 가지고 하는 것처럼 하는 라이브러리이다

설치는 
```cmd
pip install pytest-mock
```
이렇게 하면 된다
이제 `method` 안에 파라미터로 `mocker`를 추가하고 `mocking`을 진행한다
```python
def test_get_todos(mocker):

    mocker.patch("src.main.get_todos", return_value=[
        ToDo(id=1, contents="Test ToDo 1", is_done=False),
        ToDo(id=2, contents="Test ToDo 2", is_done=True)
    ])
    ...이하생략
```
윗부분만 수정하면 된다

이번엔 `fixture`를 써보려한다
> [!faq] Fixture?
> `pytest` 코드에서 반복적으로 사용하는 데이터나 객체가 있을 때 쉽게 재사용할 수 있도록 도와주는 기능

이미 쓰고 있던 기능이 있었다
바로 `mocker` 기능이다
그래도 본격적인 기능 구현을 위해 코드를 작성해보겠다

먼저, `tests` 폴더 안에 `conftest.py` 파일을 만들어준다
```py
import pytest

from fastapi.testclient import TestClient
from src.main import app

@pytest.fixture
def client():
    return TestClient(app=app)
```
이렇게 코드를 작성하게 되면 `test_main.py` 파일에서
필요 없는 `import`문을 제거하고, method의 파라미터로 `client`를 받아올 수 있다
```py
def test_health_check(client):
    response = client.get("/")
    assert response.status_code == 200
    assert response.json() == {"ping": "pong"}
```

이제 단일 조회 API의 테스트 코드를 작성해보겠다
`test_main.py` 파일에서
```py
def test_get_todo(client, mocker):
	mocker.patch("src.main.get_todo_by_id", return_value=ToDo(id=1, contents="Test ToDo 1", is_done=False))
    response = client.get("/todos/1")
    assert response.status_code == 200
    assert response.json() == {"id": 1, "contents": "FastAPI Section 0", "is_done": True}
    
    mocker.patch("src.main.get_todo_by_id", return_value=None)
    response = client.get("/todos/999")
    assert response.status_code == 404
    assert response.json() == {"detail": "ToDo not found"}
```
`200 response`와 `404 response`를 나누어서 처리할 수 있다

이어서 `POST` 처리에 `test` 코드를 적용시켜보겠다
`test_main.py` 파일로 이동한 뒤
```py
def test_create_todo(client, mocker):
    create_spy = mocker.spy(ToDo, "create")
    mocker.patch("src.main.create_todo", return_value=ToDo(id=1, contents="New ToDo", is_done=False))
    body = {
        "contents": "Test",
        "is_done": False
    }
    response = client.post("/todos", json=body)
    assert create_spy.spy_return.id is None
    assert create_spy.spy_return.contents == "Test"
    assert create_spy.spy_return.is_done is False
    assert response.status_code == 201
    assert response.json() == {"id": 1, "contents": "FastAPI Section 0", "is_done": True}
```
여기에서 `Spy`라는 개념이 나오는데 이 `Spy`는 하나의 객체를 정해서 그 객체를 계속 추적하는 기능을 가지고 있다
이런 `Spy`를 쓰지 않을 경우 `mocker`에서 실제 데이터와 다른 값이 전달되어 원래 의도했던 기능들을 모두 테스트하지 못하게 된다
이러한 위험성을 해결하기 위해서 `Spy`의 `return` 값을 받아와서 한번 더 검증을 하는 것이다

계속해서 `PATCH` 처리에도 `test` 코드를 적용하겠다
```py
def test_update_todo(client, mocker):
    mocker.patch("src.main.get_todo_by_id", return_value=ToDo(id=1, contents="Test ToDo 1", is_done=False))
    undone = mocker.patch.object(ToDo, "undone")
    mocker.patch("src.main.update_todo", return_value=ToDo(id=1, contents="Test ToDo 1", is_done=True))
    body = {
        "is_done": False
    }
    response = client.patch("/todos/1", json=body)
    undone.assert_called_once_with()
    assert response.status_code == 200
    assert response.json() == {"id": 1, "contents": "FastAPI Section 0", "is_done": True}
    
    mocker.patch("src.main.get_todo_by_id", return_value=None)
    body = {
        "is_done": True
    }
    response = client.patch("/todos/999", json=body)
    assert response.status_code == 404
    assert response.json() == {"detail": "ToDo not found"}
```
위의 단일 조회 코드를 기반으로 작성했다
여기에서 `patch`의 `object`라는 개념이 또 나오는데 이 친구는 어떤 값이 제대로 반환되고 있는지 검증하는 친구이다
이게 없으면 `is_done`값을 검증하는 코드가 제대로 실행되지 않아서 값이 `True`든 `False`든 상관없이 정상적인 요청이라고 나오게 된다

마지막으로 `DELETE` 요청에 대해서 `test` 코드를 작성하겠다
```py
def test_delete_todo(client, mocker):
    mock_delete = mocker.patch("src.main.delete_todo", return_value=True)
    response = client.delete("/todos/1")
    mock_delete.assert_called_once_with(session=mocker.ANY, todo_id=1)
    assert response.status_code == 204

    mocker.patch("src.main.delete_todo", return_value=False)
    response = client.delete("/todos/999")
    assert response.status_code == 404
    assert response.json() == {"detail": "ToDo not found"}
```
`DELETE` 요청은 반환 값이 없기 때문에 굳이 `body`를 만들어서 검증하지 않았다

다음은 섹션이 넘어가서 `FastAPI Router`를 활용한 `Refactoring` 이다
`main.py` 파일 안에 있는 `todos` 기능들을 모두 `api` 폴더를 만들어서 그 안에 `todo.py` 파일을 만들어서 그 안에 옮겼다
그리고 `test_main.py`에서 `main.`으로 테스트하던 구문들을 모두 `api.todo.`으로 고쳤다

> [!info] Dependency Injection
> - 다양한 클래스나 함수 간의 상한 결합을 줄이기 위해 사용되는 기술
> - 의존성을 사용하는 컴포넌트가 직접 정하는 것이 아니라 외부에서 전달(주입)
> - `Injector`라고 불리는 별도의 모듈에서 관리
> > [!abstract] 용어
> > - Coupling(결합) - 강하게 결합된 컴포넌트들은 수정과 변경이 어려움
> > - Dependency(의존성) - 한 컴포넌트가 올바르게 동작하기 위해 다른 요소에 의존하는 것

> [!info] Repository Pattern
> 데이터를 다루는 부분을 추상화하는 기술로 비즈니스 로직과 데이터 관리의 강한 결합을 없애준다
> 데이터를 불러오고 저장하는 것과 같은 구체적인 구현은 감춘다

1시간 남았는데 직종을 바꿔서 조금만 보려고 함

---

이번엔 React를 활용하여 간단한 Counter App을 만들어 볼 것임
```cmd
npm create vite@latest
```
명령어를 활용하여 새로운 프로젝트를 만들고
기본 세팅을 완료한 뒤
UI를 구현해보겠음
먼저 `app.jsx`임
```jsx
import './App.css'
import Viewer from './components/Viewer.jsx';
import Controller from './components/Controller.jsx';

function App() {
  return (
    <div className="App">
      <h1>Simple Counter</h1>
      <section>
        <Viewer />
      </section>
      <section>
        <Controller />
      </section>
    </div>
  )
}
export default App
```
이어서 `components`폴더를 만들고 그 안에 `Viewer.jsx`를 먼저 만들어준다
```jsx
const Viewer = () => {
    return <div>
        <div>현재 카운트 : </div>
        <h1>0</h1>
    </div>;
};
export default Viewer;
```
이어서 동일하게 `Controller.jsx`도 만들어준다
```jsx
const Controller = () => {
    return <div>
        <button>-1</button>
        <button>-10</button>
        <button>-100</button>
        <button>+100</button>
        <button>+10</button>
        <button>+1</button>
    </div>;
}
export default Controller;
```
이제 메인 UI의 스타일을 설정해주면 `App.css`
```css
body {
    padding: 20px;
}

.App {
    margin: 0 auto;
    width: 400px;
}

.App > section {
    background-color: rgb(245, 245, 245);
    border: 1px solid rgb(240, 240, 240);
    border-radius: 5px;
    padding: 20px;
    margin: 10px;
}
```
메인 UI가 완성된다

이제 기능 구현을 하겠다
`App.jsx`를 먼저 수정하면
```jsx
import './App.css'
import Viewer from './components/Viewer.jsx';
import Controller from './components/Controller.jsx';
import { useState } from 'react';

function App() {
  const [count, setCount] = useState(0);
  const onClickButton = (value) => {
    setCount(count + value);
  }
  return (
    <div className="App">
      <h1>Simple Counter</h1>
      <section>
        <Viewer count={count} />
      </section>
      <section>
        <Controller onClickButton={onClickButton} />
      </section>
    </div>
  )
}
export default App
```
최상위 부모 컴포넌트에 `State`를 선언하고 자식 `Component`에서 값을 받아와서 출력하거나 부모`component`에서 만든 `Event Handler`를 받아와서 활용하는 구조이다
이어서 `Viewer.jsx`이다
```jsx
const Viewer = ({ count }) => {
    return <div>
        <div>현재 카운트 : </div>
        <h1>{count}</h1>
    </div>;
};
export default Viewer;
```
마지막으로 `Controller.jsx`이다
```jsx
const Controller = ({ onClickButton }) => {
    return <div>
        <button onClick={() => onClickButton(-1)}>-1</button>
        <button onClick={() => onClickButton(-10)}>-10</button>
        <button onClick={() => onClickButton(-100)}>-100</button>
        <button onClick={() => onClickButton(100)}>+100</button>
        <button onClick={() => onClickButton(10)}>+10</button>
        <button onClick={() => onClickButton(1)}>+1</button>
    </div>;
}
export default Controller;
```
이렇게 부모에서 자식으로만 데이터가 전달되어지는 것을 `단방향 데이터 흐름`이라고 말한다

### 진도
---
FastAPI 41 -> 50
React 54 -> 56

### 오늘의 메모
---
막상 시간은 되게 없었는데 잘 쪼개서 열심히 해서 나름대로 진도도 많이 나간 것 같다
결과적으론 되게 만족스러운 학습이었다
내일은 첫 스터디가 있을 예정이다
본격적으로 `kmap project`에 기여하는 일이니 열심히 참여해보도록 하자

퇴근 18:00
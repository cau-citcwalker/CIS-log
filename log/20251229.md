출근 : 9:00
- Start Learning about **Fast API** 

> [!faq] Fast API란?
> ```
> - 2018년 말에 만들어진 Python 기반 Web Framework
> - 확장성이 자유롭고 가벼우며 빠른 것이 특징
> - Fast가 단순히 빠른 것 뿐만 아니라 직관적이기에 개발이 빠르다는 뜻이기도 함
> - 자동 API 문서를 생성해줌
> ```
---
>[!check] 기본 지식
> - **클라이언트** : 서비스 요청자
> - **서버** : 서비스 제공자
> - **확장 가능성** : 하나의 서버에서 다수의 클라이언트 대응 가능
> - **관심사의 분리** : 역할을 분리해서 성능, 보안에 대한 최적화
> - **HTTP 요청** : 클라이언트 -> 네트워크 -> 서버
> - **HTTP 응답** : 클라이언트 <- 네트워크 <- 서버
> - **API** : Application Programming Interface
---
> [!faq] RESTful API?
> - **REST** : Representational State Transfer
> - API를 설계하는 스타일 가이드 중 가장 많이 사용됨
> - **Resource** : URL을 통해서 고유한 리소스를 표현함
> - **Method** : HTTP Method로 API의 동작을 표현
> >[!abstract] 예시
> >```
> >GET /api/v1/posts  -> posts 표현
> >POST /api/v1//posts -> post생성
> >PATCH /api/v1/posts/123 -> post 수정
> >DELETE /api/v1/posts/123 -> post 삭제
> >```
---
> [!example] ToDo 서비스 만들기
> - **GET** :
> 	- 전체 ToDo 조회 : /api/v1/todos
> 	- 단일 ToDo 조회 : /api/v1/todos/\<id>
> - **POST** :
> 	- ToDo 생성 : /api/v1/todos
> - **PATCH** :
> 	- ToDo 수정 : /api/v1/todos/\<id>
> - **DELETE** :
> 	- ToDo 삭제 : /api/v1/todos/\<id>
---
> [!memo] 내 개인적인 방향
> - 원래 강좌에선 fastapi 0.97.0 버전을 활용하여 pydantic v1을 활용하지만 내 개인적인 욕심으로 fastapi 최신 버전을 활용하여 pydantic v2를 활용해볼 생각
> - 가이드로 올라와 있는 [docs](https://docs.pydantic.dev/latest/migration/)
---

# Fast API 에 본격적으로 들어가며
---
Fast API를 활용하려면 2가지를 설치해주어야 한다. (Python 우선 설치)
fastapi와 uvicorn (실행을 위해서 필요함)
```cmd
pip install fastapi, uvicorn
```
위 명령어를 실행하여 다운로드 받을 수 있음

docker를 활용하여 가상 환경을 우선 세팅 할 수 있다.
```docker
py -m venv <가상 환경 이름>
cd <가상 환경 이름>
```

설치와 세팅이 완료되었다면 `main.py` 파일을 만들고 내용을 작성할 수 있다.
```python
from fastapi import FastAPI

app = FastAPI()

@app.get("/") # 일반적인 루트 요청
def root_handler():
	return {"Hello":"world"}
```

실행은 다음과 같이 할 수 있음
```cmd
uvicorn main:app --reload
```
uvicorn을 이용하여 실행하고 `--reload` 옵션을 통해 livemode로 작동할 수 있음

데이터의 종류를 여러 방식으로 쓸 수도 있지만 dictionary 를 활용해보려 한다.
```python
data = {
	1: {
		"id": 1,
		"name": "naa",
		"is_super": True
	},
	2: {
		"id": 2,
		"name": "na?",
		"is_super": False
	}
}
```

이제 데이터에 접근해보려 함
URL을 통해 접근할 수 있음 `ex) localhost:8000/datas`
이렇게 하려면 뒤에 값을 받을 수 있는 핸들러가 필요함
```python
@app.get("/datas") # 전체를 한번에
def get_datas_handler():
	return data.values()

@app.get("/datas/{data_id}") # id 값에 해당하는 것 하나만
def get_data_handler(data_id: int):
	return data.get(data_id, {}) # 없으면 {}
```
만약에 파라미터로 들어가 있는 변수가 필수 요소가 아닌 경우에는 뒤에 `| None = None`를 추가하여 없이도 돌아가게 할 수 있다.

위에서 데이터에 접근을 했다면 이제 데이터를 새로 추가해보려고 한다.
우선 데이터를 새로 추가할 때 규격을 맞춰주기 위해 class를 하나 만들어 주어야 한다.
이 class는 BaseModel이라는 것을 통해서 규격을 맞춰줄 수 있다.
먼저 BaseModel을 import하고,
```python
from pydantic import BaseModel
```
class를 규격에 맞게 만들어준다.
```python
class CreateDataRequest(BaseModel):
	id: int
	name: str
	is_super: bool
```
그리고 이 규격에 맞게 값을 받아와서 post하는 handler를 만들어준다.
```python
@app.post("/datas")
def create_data_handler(request: CreateDataRequest):
	data[request.id] = request.dict() # request는 class이므로 dict()를 통해 형변환을 시켜줘야함. 이 기능은 BaseModel에서 지원함
	return data[request.id]
```

이번엔 기존의 데이터를 수정해보려고 함
patch를 활용하여 update handler를 만들 것임
그런데 우리는 다른 정보는 수정하지 않고 데이터 타입 중 한가지만 수정할 것이기 때문에 Body라는 것을 import해서 사용할 예정임
```python
from fastapi import Body
```
import를 완료했다면 patch를 통해 값을 수정하는 handler 작성하면 됨
```python
@app.patch("/datas/{data_id}")
def update_data_handler(
	data_id: int,
	is_super: bool = Body(..., embed=True) # 왜 ..., embed=True를 사용하는지는 정확한 이유는 모르겠으나, 사용하면 단일 인자에 접근할 수 있다고 강좌에서 그럼
):
	data = data.get(data_id)
	if data: # 이미 존재하는 경우에만 수정
		data["is_super"] = is_super
		return data
	return {} # 없으면 빈 데이터 반환
```
원래는 빈 데이터 일 경우 404를 반환해야 하지만 아직 상태 코드를 학습하지 않았기 때문에 학습한 후에 보완될 예정

마지막으로 데이터를 삭제해볼 것임
```python
@app.delete("/datas/{data_id}")
def delete_data_handler(data_id: int):
	data.pop(data_id, None) # pop으로 data_id값을 가진 데이터를 제거하되, 없는 데이터일 경우 None을 제거
	return data
```
원래는 리턴 값으로 삭제 시켰다는 것을 반환하거나 402 처리를 하여 반환해야 하지만 실습용 코드이기에 삭제된 이후의 나머지 데이터를 모두 반환하게 함

### 진도
---
FastAPI강좌 0 -> 20

### 오늘의 메모
---
처음 본격적으로 공부를 해보았는데 하려다가 강좌 결제를 하라고 하셔서 인프런에서 강좌 긁음..
FastAPI(53900) + React(33880) + Docker(61600) = Total(149380)...
그리고 맞은편 자리에 계신 분 본체가 아직도 조립을 못해서 다른 백엔드 개발자 분이랑 조립함
근데 문제는 조립 부품이 좀 많이 하자가 있음
다른거 다 조립 완료했는데 CPU 수냉쿨러 나사가 없어서 조립을 못끝냄
결국 공냉 쿨러 하나 새로 사기로 함..ㅋㅋ
아침엔 Chelbesa 다같이 나눠마심 행복크 :)
내일은 숭실대 가서 포탈 개발 관련하여 설명 들을 예정
아마 수요일에 이어서 HTTP Status 부터 공부하거나 React 공부 할 것 같음.

퇴근 : 18:25
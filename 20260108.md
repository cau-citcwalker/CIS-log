출근 10:15
- 오늘은 어제 하려다가 거의 못했던 React를 마저 할 예정
- 생각보다 백엔드보다 프론트 공부가 시급해짐
- 총학 웹사이트 기본 틀을 1주일 안에 잡아야하니 당분간은 프론트 먼저 공부 할 예정

원래 함수의 `return` 값으로 `html`을 반환할 수 없지만 `jsx` 문법 때문에 `html`문법을 `return`할 수 있음
심지어 `HTML`을 `return`하는 부분에 `{var}`을 활용하여 값을 보여줄 수 있은데, 이는 `숫자`, `문자열`, `배열`값만 가능하다
모든 태그는 닫혀있어야한다
최상위 태그는 반드시 하나여야한다
```jsx
<img></img>
<img/>
```

`JSX`에서 `style`을 설정할 때는 2가지 방법이 있다
하나는 직접적으로 태그에 전달하는 방법이다
```jsx
<div 
	style={{
		backgroundColor: "red",
		borderBottom: "5px solid blue",
	}}
>
	텍스트
</div>
```
이처럼 `style` 표기는 객체를 전달하며 `Camel Case` 문법을 활용한다
나머지 한가지 방법은 컴포넌트 이름의 `css` 파일을 만들어준 뒤
```css
.text {
	background-color: red,
	border-bottom: 5px solid blue
}
```
다시 `Component` 파일로 돌아와서 `import`와 수정을 해주면 된다
```jsx
import "./Component.css"

<div className="text">텍스트</div>
```


만약에 바로가기 버튼을 만드는데 값들만 다르고 동일한 구조인 경우에는 하나의 종류에서 다른 값을 전달하여 표현할 수 있다 이를 `Props`라고 한다
```jsx
function App() {
	return (
		<>
			<Button text={"a"} img={"a.png"} />
			<Button text={"b"} img={"b.png"} />
			<Button text={"c"} img={"c.png"} />
		</>
	)
}
```
```jsx
const Button = (props) => {
    return (
        <button style={{color: props.color}}>{props.text}</button>
    );
}
export default Button;
```
기본값을 설정하려면 구조분해할당을 활용하여 기본값을 설정해야한다

이벤트를 처리하는 방법은 다음과 같다
```jsx
<Button onMouseClick={(e) => {
	...
}}
>버튼</Button>
```
`e`는 혼합이벤트 객체이다
브라우저마다 이벤트와 값, 규격들이 달라서 `Cross Browsing Issue`가 발생하는데 이를 해결해주는 `React`의 문법이 `Synthetic Event`다
클릭 말고 다른 이벤트로는
```jsx
onMouseEnter 

```
등이 있다

`Component`는 `State`를 가질 수 있는데 이는 현재 `Component`의 상태를 저장하는 변수이다
이를 활용하기 위해서는 먼저 `import` 해야 한다
```jsx
import { useState } from "react";
const [state, setState] = useState(var);
```
`State`를 활용할 때는 위처럼 구조 분해 할당으로 값을 받아와서 초기 값을 `useState`의 인수값으로 설정한다
이 `State`의 값을 변경할 때에는 배열의 2번째 값인 `setState`구문으로 변경할 수 있다
기능이 다른 `State`라면 서로 분리하는 것이 불필요한 `ReRendering`을 줄여주기에 최적화를 위해서는 분리하는 것이 좋다

`input`을 통해 값을 받아오고 그걸 바로 `State`로 저장할 수 있다
```jsx
const [var, setVar] = useState("");
<input value={var} onChange={setVar} placeHolder="Input Var"/>
```
이게 너무 많아지면 코드가 비효율적으로 작성되어지게 된다
그래서 이를 방지하기 위해 `State`를 하나의 객체로 묶어서 처리할 수 있다
```jsx
const Register = () => {
	const [input, setInput] = useState({
		name: "",
		birth: "",
		country: "",
		bio: "",
		age: 0;
	});
	const onChange = (e) => { // 통합 handler
		setInput({
			...input,
			[e.target.name]: e.target.value
		});
	}
	return(
		<>
			<div>
				<input name="name" value={input.name} onChange={onChange} />
			</div>
		</>
	);
}
```
그럼 하나하나의 변경은 어떻게 하냐하면 하나의 함수로 만들어서 처리한다
어떤 값을 변경하는지는 `name` 태그로 `key`값을 정한다

> [!faq] useRef
> 새로운 `Reference` 객체를 생성하는 기능

| **useRef** | **useState** |
| :--: | :--: |
| Reference 객체를 생성 | State를 생성 |
| 컴포넌트 내부의 변수로 활용 가능 | 컴포넌트 내부의 변수로 활용 가능 |
| 어떤 경우에도 리렌더링을 유발하지 않음 | 값이 변경되면 컴포넌트 리렌더링 |
``
